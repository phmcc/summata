---
title: "Multivariate Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multivariate Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
## Use ragg for better font rendering if available
if (requireNamespace("ragg", quietly = TRUE)) {
  options(summata.use_ragg = TRUE)
}

if (requireNamespace("ragg", quietly = TRUE)) {
  knitr::opts_chunk$set(
    dev = "ragg_png",
    fig.retina = 1,
    collapse = TRUE,
    comment = "##>",
    message = FALSE,
    warning = FALSE,
    fig.width = 10,
    fig.height = 6,
    out.width = "100%"
  )
} else {
  knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "##>",
    message = FALSE,
    warning = FALSE,
    fig.width = 10,
    fig.height = 6,
    out.width = "100%"
  )
}
options(width = 180)

## Only save figures when building pkgdown site (not for CRAN)
save_figures <- identical(Sys.getenv("IN_PKGDOWN"), "true") || 
                dir.exists("../docs")  # pkgdown output directory exists

## Use vignettes/figures for generated plots (pkgdown only)
fig_dir <- "figures"
if (save_figures && !dir.exists(fig_dir)) {
  dir.create(fig_dir, recursive = TRUE)
}

## Function for saving/displaying plots
## For pkgdown: saves PNG and returns path for include_graphics
## For CRAN: just prints the plot and returns empty string
save_example_plot <- function(plot, filename, width = 10, height = 5) {
  if (save_figures) {
    filepath <- file.path(fig_dir, filename)
    final_width <- attr(plot, "recommended_dims")$width %||% width
    final_height <- attr(plot, "recommended_dims")$height %||% height
    
    if (requireNamespace("ragg", quietly = TRUE)) {
      ## Use ragg directly - it uses 'res' not 'dpi', and defaults to 72
      ## Scale dimensions to achieve effective 96 dpi appearance
      ragg::agg_png(filepath, 
                    width = final_width, 
                    height = final_height, 
                    units = "in",
                    res = 96)
      print(plot)
      grDevices::dev.off()
    } else {
      ggplot2::ggsave(filepath, plot, 
                      width = final_width, 
                      height = final_height, 
                      dpi = 96)
    }
    return(filepath)
  } else {
    print(plot)
    return(NULL)
  }
}

## Wrapper for include_graphics that handles NULL (CRAN case)
show_plot <- function(plot, filename, width = 10, height = 5) {
  path <- save_example_plot(plot, filename, width, height)
  if (!is.null(path)) {
    knitr::include_graphics(path)
  }
}
```

Multivariate analysis—in the sense employed here—refers to the simultaneous examination of a single independent variable across multiple dependent variables. This approach inverts the typical regression paradigm: rather than testing multiple predictors against one outcome (as in `uniscreen()`), multivariate analysis tests one predictor against multiple outcomes. This design is particularly useful when a key exposure or intervention must be evaluated against several endpoints simultaneously.

The `multifit()` function implements this workflow, supporting all model types available in `summata` with optional covariate adjustment, interaction terms, and mixed-effects specifications. Results can be visualized using `multiforest()` and exported using standard table export functions.

---

# Preliminaries

The examples in this vignette use the `clintrial` dataset included with `summata`:

```{r setup}
library(summata)
library(survival)
library(ggplot2)

data(clintrial)
data(clintrial_labels)
```

The `clintrial` dataset includes multiple outcome types suitable for multivariate analysis:
 
| Outcome Type | Variables | Model |
|:-------------|:----------|:------|
| Continuous | `los_days`, `pain_score`, `recovery_days` | `lm` |
| Binary | `any_complication`, `wound_infection`, `readmission_30d`, `icu_admission` | `glm` (binomial) |
| Count (equidispersed) | `fu_count` | `glm` (poisson) |
| Count (overdispersed) | `ae_count` | `negbin` or `quasipoisson` |
| Time-to-event | `Surv(pfs_months, pfs_status)`, `Surv(os_months, os_status)` | `coxph` |

---

# Multivariate vs. Univariable Screening

The distinction between `multifit()` and `uniscreen()` is important:

| Function | Tests | Use Case |
|:---------|:------|:---------|
| `uniscreen()` | Multiple predictors → One outcome | Variable screening, risk factor identification |
| `multifit()` | One predictor → Multiple outcomes | Exposure effects, intervention evaluation |

All outcomes in a single `multifit()` call should be of the same type (all binary, all continuous, or all survival). Mixing outcome types produces tables with incompatible effect measures. The function validates outcome compatibility and issues a warning when mixed types are detected.

---

# Basic Usage

## Function Signature

The function takes data as the first argument, followed by outcomes, predictor, and optional covariates:

```{r, eval = FALSE}
multifit(data, outcomes, predictor, covariates, model_type, ...)
```

## Example 1: Unadjusted Analysis

Test a single predictor against multiple binary outcomes:

```{r}
example1 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection",
               "readmission_30d", "icu_admission"),
  predictor = "surgery",
  labels = clintrial_labels,
  parallel = FALSE
)

example1
```

Each row shows the effect of the predictor on a specific outcome. For categorical predictors, each non-reference level appears separately.

## Example 2: Adjusted Analysis

Include covariates for confounding control:

```{r}
example2 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection",
               "readmission_30d", "icu_admission"),
  predictor = "surgery",
  covariates = c("age", "sex", "smoking", "diabetes"),
  labels = clintrial_labels,
  parallel = FALSE
)

example2
```

## Example 3: Unadjusted and Adjusted Comparison

Use `columns = "both"` to display unadjusted and adjusted results side-by-side:

```{r}
example3 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection",
               "readmission_30d", "icu_admission"),
  predictor = "surgery",
  covariates = c("age", "sex", "diabetes", "surgery"),
  columns = "both",
  labels = clintrial_labels,
  parallel = FALSE
)

example3
```

Comparing columns reveals confounding (large differences) or robust associations (similar estimates).

---

# Predictor Types

## **Example 4:** Continuous Predictors

For continuous predictors, one row appears per outcome:

```{r}
example4 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection", "icu_admission"),
  predictor = "age",
  covariates = c("sex", "treatment", "surgery"),
  labels = clintrial_labels,
  parallel = FALSE
)

example4
```

The effect estimate represents the change in log-odds per one-unit increase in the predictor.

## **Example 5:** Multilevel Categorical Predictors

For categorical predictors with multiple levels, the display is expanded:

```{r}
example5 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection",
               "readmission_30d", "icu_admission"),
  predictor = "treatment",
  covariates = c("age", "sex", "surgery"),
  labels = clintrial_labels,
  parallel = FALSE
)

example5
```

---

# Model Types

## **Example 6:** Cox Regression

For time-to-event outcomes, use `model_type = "coxph"`:

```{r}
example6 <- multifit(
  data = clintrial,
  outcomes = c("Surv(pfs_months, pfs_status)",
               "Surv(os_months, os_status)"),
  predictor = "treatment",
  covariates = c("age", "sex", "stage"),
  model_type = "coxph",
  labels = clintrial_labels,
  parallel = FALSE
)

example6
```

## **Example 7:** Linear Regression

For continuous outcomes, use `model_type = "lm"`:

```{r}
example7 <- multifit(
  data = clintrial,
  outcomes = c("los_days", "pain_score", "recovery_days"),
  predictor = "treatment",
  covariates = c("age", "sex", "surgery"),
  model_type = "lm",
  labels = clintrial_labels,
  parallel = FALSE
)

example7
```

## **Example 8:** Mixed-Effects Models

Account for clustering using random effects:

```{r}
example8 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection"),
  predictor = "treatment",
  covariates = c("age", "sex"),
  random = "(1|site)",
  model_type = "glmer",
  labels = clintrial_labels,
  parallel = FALSE
)

example8
```

---

# Advanced Features

## **Example 9:** Interaction Terms

Interaction terms can be added to test effect modification:

```{r}
example9 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection"),
  predictor = "treatment",
  covariates = c("age", "sex"),
  interactions = c("treatment:sex"),
  labels = clintrial_labels,
  parallel = FALSE
)

example9
```

## **Example 10:** Filtering by p-value

Outputs can be filtered to retain only significant associations:

```{r}
example10 <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection",
               "readmission_30d", "icu_admission"),
  predictor = "treatment",
  covariates = c("age", "sex", "surgery"),
  p_threshold = 0.10,
  labels = clintrial_labels,
  parallel = FALSE
)

example10
```

## **Example 11:** Accessing Model Objects

Underlying model objects are stored as attributes for additional analysis:

```{r}
result <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection"),
  predictor = "treatment",
  covariates = c("age", "sex"),
  labels = clintrial_labels,
  parallel = FALSE
)

# Access individual models
models <- attr(result, "models")
names(models)

# Examine a specific model
summary(models[["any_complication"]])
```

---

# Visualization with multiforest()

The `multiforest()` function creates forest plots from `multifit()` results.

## **Example 12:** Basic Forest Plot

Results from `multifit()` can be directly inserted into the `multiforest()` function to generate a forest plot:

```{r}
result <- multifit(
  data = clintrial,
  outcomes = c("any_complication", "wound_infection",
               "readmission_30d", "icu_admission"),
  predictor = "treatment",
  covariates = c("age", "sex", "diabetes", "surgery"),
  labels = clintrial_labels,
  parallel = FALSE
)

example12 <- multiforest(
  result,
  title = "Treatment Effects Across Outcomes",
  indent_predictor = TRUE,
  zebra_stripes = TRUE
)
```

```{r, echo = FALSE, out.width = "100%"}
show_plot(example12, "multi_ex12.png")
```

## **Example 13:** Customization Options

Customize the appearance of the forest plot by adjusting function parameters:

```{r}
example13 <- multiforest(
  result,
  title = "Effect Estimates",
  column = "adjusted",
  show_predictor = FALSE,
  covariates_footer = TRUE,
  table_width = 0.65,
  color = "#4BA6B6"
)
```

```{r, echo = FALSE, out.width = "100%"}
show_plot(example13, "multi_ex13.png")
```

## **Example 14:** Forest Plot for Survival Outcomes

The `multiforest()` function supports multiple `model_type` outputs from `multifit()`. In addition, variable labels can be applied to `multiforest()` outputs similarly to other forest plot functions:

```{r}
cox_result <- multifit(
  data = clintrial,
  outcomes = c("Surv(pfs_months, pfs_status)",
               "Surv(os_months, os_status)"),
  predictor = "treatment",
  covariates = c("age", "sex", "stage"),
  model_type = "coxph",
  parallel = FALSE
)

example14 <- multiforest(
  cox_result,
  title = "Treatment Effects on Survival Outcomes",
  indent_predictor = TRUE,
  zebra_stripes = TRUE,
  labels = clintrial_labels
)
```

```{r, echo = FALSE, out.width = "100%"}
show_plot(example14, "multi_ex14.png")
```

## **Example 15:** Forest Plot for Continuous Outcomes

Create forest plots for continuous outcomes:

```{r}
lm_result <- multifit(
  data = clintrial,
  outcomes = c("pain_score", "recovery_days", "los_days"),
  predictor = "treatment",
  covariates = c("age", "sex", "surgery"),
  model_type = "lm",
  parallel = FALSE
)

example15 <- multiforest(
  lm_result,
  title = "Treatment Effects on Recovery Metrics",
  show_predictor = FALSE,
  covariates_footer = TRUE,
  labels = clintrial_labels
)
```

```{r, echo = FALSE, out.width = "100%"}
show_plot(example15, "multi_ex15.png")
```

---

# Exporting Results

## Tables

Export tables using standard export functions:

```{r, eval = FALSE}
table2docx(
  table = result,
  file = "multioutcome_analysis.docx",
  caption = "Treatment Effects Across Outcomes"
)

table2pdf(
  table = result,
  file = "multioutcome_analysis.pdf",
  caption = "Treatment Effects Across Outcomes"
)
```

## Forest Plots

Save forest plots using `ggsave()`:

```{r, eval = FALSE}
p <- multiforest(result, title = "Effect Estimates")
dims <- attr(p, "recommended_dims")

ggsave(
  "multioutcome_forest.pdf",
  plot = p,
  width = dims$width,
  height = dims$height,
  units = "in"
)
```

---

## Complete Workflow Example

The following demonstrates a complete multi-outcome analysis workflow:

```{r}
## Define outcomes by type
binary_outcomes <- c("any_complication", "wound_infection",
                     "readmission_30d", "icu_admission")
survival_outcomes <- c("Surv(pfs_months, pfs_status)",
                       "Surv(os_months, os_status)")

## Unadjusted screening
unadjusted <- multifit(
  data = clintrial,
  outcomes = binary_outcomes,
  predictor = "treatment",
  labels = clintrial_labels,
  parallel = FALSE
)

unadjusted

## Adjusted analysis with comparison
adjusted <- multifit(
  data = clintrial,
  outcomes = binary_outcomes,
  predictor = "treatment",
  covariates = c("age", "sex", "diabetes", "surgery"),
  columns = "both",
  labels = clintrial_labels,
  parallel = FALSE
)

adjusted

## Forest plot visualization
forest_plot <- multiforest(
  adjusted,
  title = "Treatment Effect Estimates",
  column = "adjusted",
  indent_predictor = TRUE,
  zebra_stripes = TRUE,
  table_width = 0.65
)
```

```{r, echo = FALSE, out.width = "100%"}
show_plot(forest_plot, "multi_workflow_forest.png")
```

---

## Parameter Reference

| Parameter | Description |
|:----------|:------------|
| `outcomes` | Character vector of outcome variable names |
| `predictor` | Single predictor variable name |
| `covariates` | Optional adjustment covariates |
| `interactions` | Interaction terms (colon notation) |
| `random` | Random effects formula for mixed models |
| `strata` | Stratification variable (Cox models) |
| `cluster` | Clustering variable for robust standard errors |
| `model_type` | `"glm"`, `"lm"`, `"coxph"`, `"glmer"`, `"lmer"`, `"coxme"` |
| `family` | GLM family (default: `"binomial"`) |
| `columns` | `"adjusted"`, `"unadjusted"`, or `"both"` |
| `p_threshold` | Filter results by *p*-value |
| `labels` | Custom variable labels |
| `parallel` | Enable parallel processing |

---

## Best Practices

### Outcome Selection

1. Use compatible outcome types within a single analysis
2. Group conceptually related outcomes
3. Consider multiple testing adjustments when testing many outcomes

### Adjustment Strategy

1. Pre-specify covariates based on domain knowledge
2. Use `columns = "both"` to assess confounding
3. Apply consistent covariates across outcomes for comparability

### Interpretation

1. Focus on effect magnitude and precision, not only *p*-values
2. Look for consistent patterns across related outcomes
3. Consider practical significance alongside statistical significance

---

## Common Issues

### Empty Results

If results are empty, verify:

- Predictor variable exists and has variation
- Outcomes are correctly specified (`Surv()` syntax for survival)
- Model type matches outcome type

### Convergence Warnings

For mixed-effects models, simplify the random effects structure:

```{r, eval = FALSE}
## Start with random intercepts only
multifit(data, outcomes, predictor,
         random = "(1|site)",
         model_type = "glmer")
```

### Many Factor Levels

For predictors with many levels, consider collapsing categories:

```{r, eval = FALSE}
clintrial$treatment_binary <- ifelse(clintrial$treatment == "Control", 
                                      "Control", "Active")
```

### Categorical Outcomes with More Than Two Levels

`multifit()` supports binary outcomes (via logistic regression) but not multinomial or ordinal outcomes. If you include a categorical outcome with three or more levels (e.g., treatment group with "Control", "Drug A", "Drug B"), the function will issue a warning because binomial GLM coerces such variables to binary (first level *vs.* all others).

For multi-level categorical outcomes, use dedicated packages outside of `summata`:

```{r, eval = FALSE}
## Multinomial regression (unordered categories)
library(nnet)
model <- multinom(treatment ~ age + sex + stage, data = clintrial)

## Ordinal regression (ordered categories)
library(MASS)
model <- polr(grade ~ age + sex + stage, data = clintrial, Hess = TRUE)
```

---

## Further Reading

- [Statistical Foundations](statistical_foundations.html): Mathematical details for all model types
- [Descriptive Tables](descriptive_tables.html): `desctable()` for baseline characteristics
- [Regression Modeling](regression_modeling.html): `fit()`, `uniscreen()`, and `fullfit()`
- [Model Comparison](model_comparison.html): `compfit()` for comparing models
- [Table Export](table_export.html): Export to PDF, Word, and other formats
- [Forest Plots](forest_plots.html): Visualization of regression results
- [Advanced Workflows](advanced_workflows.html): Interactions and mixed-effects models
