% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multifit.R
\name{multifit}
\alias{multifit}
\title{Multivariate Regression Analysis}
\usage{
multifit(
  data,
  outcomes,
  predictor,
  covariates = NULL,
  interactions = NULL,
  random = NULL,
  strata = NULL,
  cluster = NULL,
  model_type = "glm",
  family = "binomial",
  columns = "adjusted",
  p_threshold = 1,
  conf_level = 0.95,
  show_n = TRUE,
  show_events = TRUE,
  digits = 2,
  p_digits = 3,
  labels = NULL,
  predictor_label = NULL,
  include_predictor = TRUE,
  keep_models = FALSE,
  exponentiate = NULL,
  parallel = TRUE,
  n_cores = NULL,
  ...
)
}
\arguments{
\item{data}{A data.frame or data.table containing the analysis dataset. The 
function automatically converts data.frames to data.tables for efficient 
processing.}

\item{outcomes}{Character vector of outcome variable names to analyze. Each 
outcome is tested in its own model with the predictor. For survival analysis, 
use \code{Surv()} syntax (e.g., \code{c("Surv(time1, status1)", "Surv(time2, status2)")}).}

\item{predictor}{Character string specifying the predictor (exposure) variable 
name. This variable is tested against each outcome. Can be continuous or 
categorical (factor).}

\item{covariates}{Optional character vector of covariate variable names to 
include in adjusted models. When specified, models are fit as 
\code{outcome ~ predictor + covariate1 + covariate2 + ...}, and only the 
predictor effect is reported. Default is \code{NULL} (unadjusted models).}

\item{interactions}{Optional character vector of interaction terms to include
in adjusted models, using colon notation (e.g., \code{c("predictor:sex")}).
Interactions involving the predictor will have their effects extracted and
reported. Default is \code{NULL}.}

\item{random}{Optional character string specifying random effects formula for
mixed effects models (e.g., \code{"(1|hospital)"} or \code{"(1|site/patient)"}).
Required when \code{model_type} is \code{"glmer"}, \code{"lmer"}, or 
\code{"coxme"}. Default is \code{NULL}.}

\item{strata}{Optional character string naming the stratification variable for
Cox or conditional logistic models. Creates separate baseline hazards for 
each stratum. Default is \code{NULL}.}

\item{cluster}{Optional character string naming the clustering variable for
Cox models. Computes robust clustered standard errors. Default is \code{NULL}.}

\item{model_type}{Character string specifying the type of regression model to 
fit. Options include:
\itemize{
  \item \code{"glm"} - Generalized linear model (default). Supports multiple 
    distributions via the \code{family} parameter including logistic, Poisson, 
    Gamma, Gaussian, and quasi-likelihood models.
  \item \code{"negbin"} - Negative binomial regression for overdispersed count 
    data (requires MASS package). Estimates an additional dispersion parameter 
    compared to Poisson regression.
  \item \code{"lm"} - Linear regression for continuous outcomes with normally 
    distributed errors.
  \item \code{"coxph"} - Cox proportional hazards model for time-to-event 
    survival analysis. Requires \code{Surv()} outcome syntax.
  \item \code{"clogit"} - Conditional logistic regression for matched 
    case-control studies.
  \item \code{"glmer"} - Generalized linear mixed-effects model for hierarchical 
    or clustered data with non-normal outcomes (requires lme4 package and 
    \code{random} parameter).
  \item \code{"lmer"} - Linear mixed-effects model for hierarchical or clustered 
    data with continuous outcomes (requires lme4 package and \code{random} 
    parameter).
  \item \code{"coxme"} - Cox mixed-effects model for clustered survival data 
    (requires coxme package and \code{random} parameter).
}}

\item{family}{For GLM and GLMER models, specifies the error distribution and link 
function. Can be a character string, a family function, or a family object.
Ignored for non-GLM/GLMER models.

\strong{Binary/Binomial outcomes:}
\itemize{
  \item \code{"binomial"} or \code{binomial()} - Logistic regression for binary 
    outcomes (0/1, TRUE/FALSE). Returns odds ratios (OR). Default.
  \item \code{"quasibinomial"} or \code{quasibinomial()} - Logistic regression 
    with overdispersion. Use when residual deviance >> residual df.
  \item \code{binomial(link = "probit")} - Probit regression (normal CDF link).
  \item \code{binomial(link = "cloglog")} - Complementary log-log link for 
    asymmetric binary outcomes.
}

\strong{Count outcomes:}
\itemize{
  \item \code{"poisson"} or \code{poisson()} - Poisson regression for count 
    data. Returns rate ratios (RR). Assumes mean = variance.
  \item \code{"quasipoisson"} or \code{quasipoisson()} - Poisson regression 
    with overdispersion. Use when variance > mean.
}

\strong{Continuous outcomes:}
\itemize{
  \item \code{"gaussian"} or \code{gaussian()} - Normal/Gaussian distribution 
    for continuous outcomes. Equivalent to linear regression.
  \item \code{gaussian(link = "log")} - Log-linear model for positive continuous 
    outcomes. Returns multiplicative effects.
}

\strong{Positive continuous outcomes:}
\itemize{
  \item \code{"Gamma"} or \code{Gamma()} - Gamma distribution for positive, 
    right-skewed continuous data (e.g., costs, lengths of stay). Default log link.
  \item \code{Gamma(link = "inverse")} - Gamma with inverse (canonical) link.
  \item \code{Gamma(link = "identity")} - Gamma with identity link for additive 
    effects on positive outcomes.
  \item \code{"inverse.gaussian"} or \code{inverse.gaussian()} - Inverse Gaussian 
    for positive, highly right-skewed data.
}

For negative binomial regression (overdispersed counts), use 
\code{model_type = "negbin"} instead of the \code{family} parameter.

See \code{\link[stats]{family}} for additional details and options.}

\item{columns}{Character string specifying which result columns to display when 
both unadjusted and adjusted models are fit (i.e., when \code{covariates} is 
specified):
\itemize{
  \item \code{"adjusted"} - Show only adjusted (covariate-controlled) results [default]
  \item \code{"unadjusted"} - Show only unadjusted (crude) results
  \item \code{"both"} - Show both unadjusted and adjusted results side-by-side
}
Ignored when \code{covariates = NULL}.}

\item{p_threshold}{Numeric value between 0 and 1 specifying a p-value threshold 
for filtering results. Only outcomes with p-value <= threshold are included 
in the output. Default is 1 (no filtering, all outcomes returned).}

\item{conf_level}{Numeric confidence level for confidence intervals. Must be 
between 0 and 1. Default is 0.95 (95\% confidence intervals).}

\item{show_n}{Logical. If \code{TRUE}, includes the sample size column in 
the output table. Default is \code{TRUE}.}

\item{show_events}{Logical. If \code{TRUE}, includes the events column in the 
output table (relevant for survival and logistic regression). Default is 
\code{TRUE}.}

\item{digits}{Integer specifying the number of decimal places for effect 
estimates (OR, HR, RR, coefficients). Default is 2.}

\item{p_digits}{Integer specifying the number of decimal places for p-values. 
P-values smaller than \code{10^(-p_digits)} are displayed as "< 0.001", 
etc. Default is 3.}

\item{labels}{Named character vector or list providing custom display 
labels for variables. Can include labels for outcomes, predictors, and 
covariates. Names should match variable names, values are the display labels.
Labels are applied to: (1) outcome names in the Outcome column, (2) predictor
variable name when displayed, and (3) variable names in formatted interaction
terms. Variables not in \code{labels} use their original names. 
Default is \code{NULL}.}

\item{predictor_label}{Optional character string providing a custom display 
label for the predictor variable. Takes precedence over \code{labels} for
the predictor. Default is \code{NULL} (uses label from \code{labels} or 
original name).}

\item{include_predictor}{Logical. If \code{TRUE} (default), includes the 
Predictor column in the output table showing which level of a factor 
predictor is being compared. If \code{FALSE}, omits the Predictor column,
which may be useful when the predictor information will be explained in 
a table caption or figure legend.}

\item{keep_models}{Logical. If \code{TRUE}, stores all fitted model objects 
in the output as an attribute. Models are accessible via 
\code{attr(result, "models")}. Default is \code{FALSE}.}

\item{exponentiate}{Logical. Whether to exponentiate coefficients (display 
OR/HR/RR instead of log odds/log hazards). Default is \code{NULL}, which 
automatically exponentiates for logistic, Poisson, and Cox models, and 
displays raw coefficients for linear models.}

\item{parallel}{Logical. If \code{TRUE}, fits models in parallel for improved 
performance with many outcomes. Default is \code{TRUE}.}

\item{n_cores}{Integer. Number of cores for parallel processing. Default is 
\code{NULL} (auto-detect: uses number of available cores - 1).}

\item{...}{Additional arguments passed to the underlying model fitting functions.}
}
\value{
A data.table with S3 class \code{"multifit_result"} containing formatted 
  multivariate results. The table structure includes:
  \describe{
    \item{Outcome}{Character. Outcome variable name or custom label}
    \item{Predictor}{Character. For factor predictors: formatted as 
      "Variable (Level)" showing the level being compared to reference.
      For binary variables where the non-reference level is an affirmative
      value (Yes, 1, True, Present, Positive, +), shows just "Variable".
      For continuous predictors: the variable name. For interactions: the
      formatted interaction term (e.g., "Treatment (Drug A) × Sex (Male)")}
    \item{n}{Integer. Sample size used in the model (if \code{show_n = TRUE})}
    \item{Events}{Integer. Number of events (if \code{show_events = TRUE})}
    \item{OR/HR/RR/Coefficient (95\% CI)}{Character. Unadjusted effect 
      estimate with CI (if \code{columns = "unadjusted"} or \code{"both"})}
    \item{aOR/aHR/aRR/Adj. Coefficient (95\% CI)}{Character. Adjusted 
      effect estimate with CI (if \code{columns = "adjusted"} or \code{"both"})}
    \item{Uni p / Multi p / p-value}{Character. Formatted p-value(s). Column 
      names depend on \code{columns} setting}
  }
  
  The returned object includes the following attributes accessible via \code{attr()}:
  \describe{
    \item{raw_data}{data.table. Unformatted numeric results with separate 
      columns for effect estimates, standard errors, confidence intervals, 
      and p-values. Suitable for custom analysis or visualization}
    \item{models}{list (if \code{keep_models = TRUE}). Named list of fitted 
      model objects, with outcome names as list names. Each element contains
      \code{$unadjusted} and/or \code{$adjusted} models depending on settings}
    \item{predictor}{Character. The predictor variable name}
    \item{outcomes}{Character vector. The outcome variable names}
    \item{covariates}{Character vector or NULL. The covariate variable names}
    \item{interactions}{Character vector or NULL. The interaction terms}
    \item{random}{Character or NULL. The random effects formula}
    \item{strata}{Character or NULL. The stratification variable}
    \item{cluster}{Character or NULL. The clustering variable}
    \item{model_type}{Character. The regression model type used}
    \item{columns}{Character. Which columns were displayed}
    \item{analysis_type}{Character. "multi_outcome" to identify analysis type}
  }
}
\description{
Performs regression analyses of a single predictor (exposure) across multiple 
outcomes. This function is designed for studies where a single exposure variable 
is tested against multiple endpoints, such as complication screening, biomarker 
associations, or phenome-wide association studies. Returns publication-ready 
formatted results with optional covariate adjustment. Supports interactions,
mixed effects models, stratification, and clustered standard errors.
}
\details{
\strong{Analysis Approach:}

The function implements a multivariate (multi-outcome) screening workflow that
inverts the typical regression paradigm:
\enumerate{
  \item For each outcome in \code{outcomes}, fits a separate model with the 
    predictor as the main exposure
  \item If \code{covariates} specified, fits adjusted model: 
    \code{outcome ~ predictor + covariates + interactions}
  \item Extracts only the predictor effect(s) from each model, ignoring 
    covariate coefficients
  \item Combines results into a single table for comparison across outcomes
  \item Optionally filters by p-value threshold
}

This is conceptually opposite to \code{\link{uniscreen}}, which tests multiple 
predictors against a single outcome. Use \code{multifit} when you have one 
exposure of interest and want to screen across multiple endpoints.

\strong{When to Use Multivariate Analysis:}
\itemize{
  \item \strong{Complication screening}: Test one exposure (e.g., operative time, 
    BMI, biomarker level) against multiple postoperative complications
  \item \strong{Treatment effects}: Test one treatment against multiple efficacy 
    and safety endpoints simultaneously
  \item \strong{Biomarker studies}: Test one biomarker against multiple clinical 
    outcomes to understand its prognostic value
  \item \strong{Phenome-wide association studies (PheWAS)}: Test genetic variants 
    or exposures against many phenotypes
  \item \strong{Risk factor profiling}: Understand how one risk factor relates 
    to a spectrum of outcomes
}

\strong{Handling Categorical Predictors:}

When the predictor is a factor variable with multiple levels:
\itemize{
  \item Each non-reference level gets its own row for each outcome
  \item Reference category is determined by factor level ordering
  \item The Predictor column shows "Variable (Level)" format 
    (e.g., "Treatment (Drug A)", "Treatment (Drug B)")
  \item For binary variables with affirmative non-reference levels 
    (Yes, 1, True, Present, Positive, +), shows just "Variable" 
    (e.g., "Diabetes" instead of "Diabetes (Yes)")
  \item Effect estimates compare each level to the reference
}

\strong{Adjusted vs. Unadjusted Results:}

When \code{covariates} is specified, the function fits both models but only 
extracts predictor effects:
\itemize{
  \item \code{columns = "adjusted"}: Reports only covariate-adjusted effects.
    Column labeled "Multivariable aOR/aHR" etc.
  \item \code{columns = "unadjusted"}: Reports only crude effects. Column 
    labeled "Univariable OR/HR" etc.
  \item \code{columns = "both"}: Reports both side-by-side. Useful for 
    identifying confounding (large change in effect) or independent effects 
    (similar estimates)
}

\strong{Interaction Terms:}

When \code{interactions} includes terms involving the predictor:
\itemize{
  \item Main effect of predictor is always reported
  \item Interaction effects are extracted and displayed with formatted names
  \item Format: "Variable (Level) × Variable (Level)" using multiplication sign notation
  \item Useful for testing effect modification (e.g., does treatment effect 
    differ by sex?)
}

\strong{Mixed Effects Models:}

For clustered or hierarchical data (e.g., patients within hospitals):
\itemize{
  \item Use \code{model_type = "glmer"} with \code{random = "(1|cluster)"} for 
    random intercept models
  \item Nested random effects: \code{random = "(1|site/patient)"}
  \item Crossed random effects: \code{random = "(1|site) + (1|doctor)"}
  \item For survival outcomes, use \code{model_type = "coxme"}
}

\strong{Stratification and Clustering (Cox models):}

For Cox proportional hazards models:
\itemize{
  \item \code{strata}: Creates separate baseline hazards for each stratum level.
    Use when hazards are non-proportional across strata but you don't want to 
    estimate stratum effects
  \item \code{cluster}: Computes robust (sandwich) standard errors accounting 
    for within-cluster correlation. Alternative to mixed effects when only 
    robust SEs are needed
}

\strong{P-value Filtering:}

The \code{p_threshold} parameter filters results after fitting all models:
\itemize{
  \item Only outcomes with p <= threshold are retained in output
  \item For factor predictors, outcome is kept if any level is significant
  \item Useful for focusing on significant associations in exploratory analyses
  \item Default is 1 (no filtering) - recommended for confirmatory analyses
}

\strong{Outcome Homogeneity:}

All outcomes in a single \code{multifit()} call should be of the same type
(all binary, all continuous, or all survival). Mixing outcome types produces
tables with incompatible effect measures (e.g., odds ratios alongside regression
coefficients), which can mislead readers. The function validates outcome
compatibility and issues a warning when mixed types are detected.

For analyses involving multiple outcome types, run separate \code{multifit()}
calls for each type:

\preformatted{
# Binary outcomes
binary_results <- multifit(data, outcomes = c("death", "readmission"),
                           predictor = "treatment", model_type = "glm")

# Continuous outcomes
continuous_results <- multifit(data, outcomes = c("los_days", "cost"),
                               predictor = "treatment", model_type = "lm")
}

\strong{Effect Measures by Model Type:}
\itemize{
  \item \strong{Logistic} (\code{model_type = "glm"}, \code{family = "binomial"}): 
    Odds ratios (OR/aOR)
  \item \strong{Cox} (\code{model_type = "coxph"}): Hazard ratios (HR/aHR)
  \item \strong{Poisson} (\code{model_type = "glm"}, \code{family = "poisson"}): 
    Rate ratios (RR/aRR)
  \item \strong{Linear} (\code{model_type = "lm"}): Coefficient estimates
  \item \strong{Mixed effects}: Same as fixed effects counterparts
}

\strong{Memory and Performance:}

\itemize{
  \item \code{parallel = TRUE} (default) uses multiple cores for faster fitting
  \item \code{keep_models = FALSE} (default) discards model objects to save memory
  \item For many outcomes, parallel processing provides substantial speedup
  \item Set \code{keep_models = TRUE} only when you need model diagnostics
}
}
\examples{
# Load example data
data(clintrial)
data(clintrial_labels)

# Example 1: Basic multivariate analysis (unadjusted)
# Test treatment effect on multiple binary outcomes
result1 <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "treatment",
    labels = clintrial_labels,
    parallel = FALSE
)
print(result1)
# Shows odds ratios comparing Drug A and Drug B to Control

\donttest{
# Example 2: Adjusted analysis with covariates
# Adjust for age, sex, and disease stage
result2 <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    labels = clintrial_labels,
    parallel = FALSE
)
print(result2)
# Shows adjusted odds ratios (aOR)

# Example 3: Compare unadjusted and adjusted results
result3 <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    columns = "both",
    labels = clintrial_labels,
    parallel = FALSE
)
print(result3)
# Useful for identifying confounding effects

# Example 4: Continuous predictor across outcomes
# Test age effect on multiple outcomes
result4 <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "age",
    covariates = c("sex", "treatment", "stage"),
    labels = clintrial_labels,
    parallel = FALSE
)
print(result4)
# One row per outcome for continuous predictor

# Example 5: Cox regression for survival outcomes
library(survival)
cox_result <- multifit(
    data = clintrial,
    outcomes = c("Surv(pfs_months, pfs_status)", 
                 "Surv(os_months, os_status)"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    model_type = "coxph",
    labels = clintrial_labels,
    parallel = FALSE
)
print(cox_result)
# Returns hazard ratios (HR/aHR)

# Example 6: Cox with stratification by site
cox_strat <- multifit(
    data = clintrial,
    outcomes = c("Surv(os_months, os_status)"),
    predictor = "treatment",
    covariates = c("age", "sex"),
    strata = "site",
    model_type = "coxph",
    labels = clintrial_labels,
    parallel = FALSE
)
print(cox_strat)

# Example 7: Cox with clustered standard errors
cox_cluster <- multifit(
    data = clintrial,
    outcomes = c("Surv(os_months, os_status)"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    cluster = "site",
    model_type = "coxph",
    labels = clintrial_labels,
    parallel = FALSE
)
print(cox_cluster)

# Example 8: Interaction between predictor and covariate
# Test if treatment effect differs by sex
result_int <- multifit(
    data = clintrial,
    outcomes = c("surgery", "os_status"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    interactions = c("treatment:sex"),
    labels = clintrial_labels,
    parallel = FALSE
)
print(result_int)
# Shows main effects and interaction terms with × notation

# Example 9: Linear model for continuous outcomes
linear_result <- multifit(
    data = clintrial,
    outcomes = c("los_days", "biomarker_x"),
    predictor = "treatment",
    covariates = c("age", "sex"),
    model_type = "lm",
    labels = clintrial_labels,
    parallel = FALSE
)
print(linear_result)
# Returns coefficient estimates, not ratios

# Example 10: Poisson regression for count outcomes
poisson_result <- multifit(
    data = clintrial,
    outcomes = c("los_days"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    model_type = "glm",
    family = "poisson",
    labels = clintrial_labels,
    parallel = FALSE
)
print(poisson_result)
# Returns rate ratios (RR)

# Example 11: Filter to significant results only
sig_results <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "stage",
    p_threshold = 0.05,
    labels = clintrial_labels,
    parallel = FALSE
)
print(sig_results)
# Only outcomes with significant associations shown

# Example 12: Custom outcome labels
result_labeled <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "treatment",
    labels = c(
        surgery = "Surgical Resection",
        pfs_status = "Disease Progression",
        os_status = "Death",
        treatment = "Treatment Group"
    ),
    parallel = FALSE
)
print(result_labeled)

# Example 13: Keep models for diagnostics
result_models <- multifit(
    data = clintrial,
    outcomes = c("surgery", "os_status"),
    predictor = "treatment",
    covariates = c("age", "sex"),
    keep_models = TRUE,
    parallel = FALSE
)

# Access stored models
models <- attr(result_models, "models")
names(models)

# Get adjusted model for surgery outcome
surgery_model <- models$surgery$adjusted
summary(surgery_model)

# Example 14: Access raw numeric data
result <- multifit(
    data = clintrial,
    outcomes = c("surgery", "os_status"),
    predictor = "age",
    parallel = FALSE
)

# Get unformatted results for custom analysis
raw_data <- attr(result, "raw_data")
print(raw_data)
# Contains exp_coef, ci_lower, ci_upper, p_value, etc.

# Example 15: Hide sample size and event columns
result_minimal <- multifit(
    data = clintrial,
    outcomes = c("surgery", "os_status"),
    predictor = "treatment",
    show_n = FALSE,
    show_events = FALSE,
    parallel = FALSE
)
print(result_minimal)

# Example 16: Customize decimal places
result_digits <- multifit(
    data = clintrial,
    outcomes = c("surgery", "os_status"),
    predictor = "age",
    digits = 3,
    p_digits = 4,
    parallel = FALSE
)
print(result_digits)

# Example 17: Force coefficient display (no exponentiation)
result_coef <- multifit(
    data = clintrial,
    outcomes = c("surgery"),
    predictor = "age",
    exponentiate = FALSE,
    parallel = FALSE
)
print(result_coef)

# Example 18: Complete publication workflow
final_table <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage", "grade"),
    columns = "both",
    labels = clintrial_labels,
    digits = 2,
    p_digits = 3,
    parallel = FALSE
)
print(final_table)

# Export to various formats for publication
# table2pdf(final_table, "treatment_effects.pdf", 
#         caption = "Treatment effects across outcomes")
# table2docx(final_table, "treatment_effects.docx")

# Example 19: Create forest plot from results
result_forest <- multifit(
    data = clintrial,
    outcomes = c("surgery", "pfs_status", "os_status"),
    predictor = "treatment",
    covariates = c("age", "sex", "stage"),
    labels = clintrial_labels,
    parallel = FALSE
)

# Create forest plot (requires ggplot2)
# p <- multiforest(result_forest, 
#                  title = "Treatment Effects Across Outcomes")
# print(p)

}

}
\seealso{
\code{\link{uniscreen}} for screening multiple predictors against one outcome,
\code{\link{multiforest}} for creating forest plots from multifit results,
\code{\link{fit}} for single-outcome regression with full coefficient output,
\code{\link{fullfit}} for complete univariable-to-multivariable workflow
}
